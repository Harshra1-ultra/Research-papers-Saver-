import React, { useState, useEffect } from 'react';
import { initializeApp } from 'firebase/app';
import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from 'firebase/auth';
import { getFirestore, collection, addDoc, onSnapshot, query, orderBy } from 'firebase/firestore';

// Define global variables for Firebase configuration (provided by the environment)
const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : {};
const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

// Main App component
export default function App() {
    const [linkInput, setLinkInput] = useState('');
    const [headingInput, setHeadingInput] = useState('');
    const [keywordsInput, setKeywordsInput] = useState('');
    const [papers, setPapers] = useState([]);
    const [isLoading, setIsLoading] = useState(false);
    const [error, setError] = useState('');
    const [db, setDb] = useState(null);
    const [auth, setAuth] = useState(null);
    const [userId, setUserId] = useState(null);
    const [isAuthReady, setIsAuthReady] = useState(false);

    // Initialize Firebase and handle authentication
    useEffect(() => {
        try {
            const app = initializeApp(firebaseConfig);
            const firestoreDb = getFirestore(app);
            const firebaseAuth = getAuth(app);

            setDb(firestoreDb);
            setAuth(firebaseAuth);

            // Listen for authentication state changes
            const unsubscribe = onAuthStateChanged(firebaseAuth, async (user) => {
                if (user) {
                    setUserId(user.uid);
                } else {
                    // Sign in anonymously if no user is authenticated
                    try {
                        if (initialAuthToken) {
                            await signInWithCustomToken(firebaseAuth, initialAuthToken);
                        } else {
                            await signInAnonymously(firebaseAuth);
                        }
                    } catch (authError) {
                        console.error("Firebase Auth Error:", authError);
                        setError("Failed to authenticate. Please try again.");
                    }
                }
                setIsAuthReady(true); // Auth state is ready
            });

            return () => unsubscribe(); // Cleanup auth listener
        } catch (initError) {
            console.error("Firebase Initialization Error:", initError);
            setError("Failed to initialize Firebase. Check console for details.");
        }
    }, []);

    // Fetch papers from Firestore in real-time
    useEffect(() => {
        if (db && userId && isAuthReady) {
            const papersCollectionRef = collection(db, `artifacts/${appId}/users/${userId}/researchPapers`);
            // Note: orderBy is commented out as per instructions to avoid potential index issues.
            // Data will be sorted in client-side.
            const q = query(papersCollectionRef); // , orderBy('heading', 'asc'));

            const unsubscribe = onSnapshot(q, (snapshot) => {
                const fetchedPapers = snapshot.docs.map(doc => ({
                    id: doc.id,
                    ...doc.data()
                }));
                // Sort papers by heading client-side
                fetchedPapers.sort((a, b) => a.heading.localeCompare(b.heading));
                setPapers(fetchedPapers);
            }, (err) => {
                console.error("Firestore Error:", err);
                setError("Failed to load papers. Please try again.");
            });

            return () => unsubscribe(); // Cleanup snapshot listener
        }
    }, [db, userId, isAuthReady]);

    // Function to extract heading and keywords using LLM
    const handleExtractFromLink = async () => {
        if (!linkInput) {
            setError("Please enter a link to extract from.");
            return;
        }
        setIsLoading(true);
        setError('');

        try {
            // Step 1: Use google_search to find the content related to the link
            // This is a placeholder for a more robust web scraping mechanism.
            // In a real scenario, you'd need a backend service to fetch and parse HTML.
            // For now, we'll try to browse the link directly.
            console.log(`Attempting to browse: ${linkInput}`);
            const browsedContent = await new Promise((resolve, reject) => {
                window.google_search({
                    query: `site:${new URL(linkInput).hostname} OR "${linkInput}"`, // Tries to find content on the site or the exact link
                    search_type: 'browse',
                    num_results: 1,
                    callback: (result) => {
                        if (result.results && result.results.length > 0 && result.results[0].snippet) {
                            resolve(result.results[0].snippet);
                        } else {
                            reject(new Error("No browsable content found for the given link."));
                        }
                    }
                });
            });

            if (!browsedContent) {
                throw new Error("Could not browse content for the provided link.");
            }

            // Step 2: Use an LLM to extract heading and keywords from the browsed content
            const prompt = `Given the following text content from a research paper link, extract the main heading and relevant keywords.
            Text: "${browsedContent}"

            Output format:
            Heading: [Extracted Heading]
            Keywords: [Keyword1, Keyword2, Keyword3,...]`;

            const llmResult = await window.ai.generateText({ prompt: prompt });
            const generatedText = llmResult.text;

            // Parse the LLM output
            const headingMatch = generatedText.match(/Heading: (.*)/);
            const keywordsMatch = generatedText.match(/Keywords: (.*)/);

            if (headingMatch && keywordsMatch) {
                setHeadingInput(headingMatch[1].trim());
                setKeywordsInput(keywordsMatch[1].trim());
            } else {
                setError("Could not extract heading and keywords. Please check the link or try manual entry.");
            }

        } catch (err) {
            console.error("Extraction Error:", err);
            setError(`Failed to extract data: ${err.message}. Please try manual entry or a different link.`);
        } finally {
            setIsLoading(false);
        }
    };

    // Function to add a paper to Firestore
    const handleAddPaper = async (e) => {
        e.preventDefault();
        if (!linkInput || !headingInput || !keywordsInput) {
            setError("All fields are required to add a paper.");
            return;
        }
        if (!db || !userId) {
            setError("Database not ready. Please wait or refresh.");
            return;
        }

        setIsLoading(true);
        setError('');

        try {
            const papersCollectionRef = collection(db, `artifacts/${appId}/users/${userId}/researchPapers`);
            await addDoc(papersCollectionRef, {
                link: linkInput,
                heading: headingInput,
                keywords: keywordsInput.split(',').map(k => k.trim()), // Store keywords as an array
                timestamp: new Date()
            });
            setLinkInput('');
            setHeadingInput('');
            setKeywordsInput('');
        } catch (err) {
            console.error("Error adding document: ", err);
            setError("Failed to add paper. Please try again.");
        } finally {
            setIsLoading(false);
        }
    };

    // Group papers by heading for display
    const groupedPapers = papers.reduce((acc, paper) => {
        const firstLetter = paper.heading.charAt(0).toUpperCase();
        if (!acc[firstLetter]) {
            acc[firstLetter] = [];
        }
        acc[firstLetter].push(paper);
        return acc;
    }, {});

    const sortedLetters = Object.keys(groupedPapers).sort();

    if (!isAuthReady) {
        return <div style={styles.loadingContainer}>Loading authentication...</div>;
    }

    return (
        <div style={styles.container}>
            <h1 style={styles.header}>Research Paper Collector</h1>

            {error && <p style={styles.error}>{error}</p>}

            <form onSubmit={handleAddPaper} style={styles.form}>
                <div style={styles.inputGroup}>
                    <label htmlFor="link" style={styles.label}>Paper Link:</label>
                    <input
                        type="url"
                        id="link"
                        value={linkInput}
                        onChange={(e) => setLinkInput(e.target.value)}
                        placeholder="e.g., https://arxiv.org/abs/2301.00001"
                        style={styles.input}
                        required
                    />
                    <button type="button" onClick={handleExtractFromLink} disabled={isLoading} style={styles.extractButton}>
                        {isLoading ? 'Extracting...' : 'Extract from Link'}
                    </button>
                </div>

                <div style={styles.inputGroup}>
                    <label htmlFor="heading" style={styles.label}>Paper Heading:</label>
                    <input
                        type="text"
                        id="heading"
                        value={headingInput}
                        onChange={(e) => setHeadingInput(e.target.value)}
                        placeholder="e.g., A Novel Approach to AI"
                        style={styles.input}
                        required
                    />
                </div>

                <div style={styles.inputGroup}>
                    <label htmlFor="keywords" style={styles.label}>Keywords (comma-separated):</label>
                    <input
                        type="text"
                        id="keywords"
                        value={keywordsInput}
                        onChange={(e) => setKeywordsInput(e.target.value)}
                        placeholder="e.g., AI, Machine Learning, Research"
                        style={styles.input}
                        required
                    />
                </div>

                <button type="submit" disabled={isLoading} style={styles.button}>
                    {isLoading ? 'Adding Paper...' : 'Add Paper'}
                </button>
            </form>

            <h2 style={styles.listHeader}>Collected Papers</h2>
            {papers.length === 0 && !isLoading ? (
                <p>No papers collected yet. Add one above!</p>
            ) : (
                <div style={styles.paperListContainer}>
                    {sortedLetters.map(letter => (
                        <div key={letter} style={styles.letterGroup}>
                            <h3 style={styles.letterHeading}>{letter}</h3>
                            <ul style={styles.paperList}>
                                {groupedPapers[letter].map(paper => (
                                    <li key={paper.id} style={styles.paperItem}>
                                        <a href={paper.link} target="_blank" rel="noopener noreferrer" style={styles.paperLink}>
                                            {paper.heading}
                                        </a>
                                        <p style={styles.keywords}>Keywords: {paper.keywords.join(', ')}</p>
                                    </li>
                                ))}
                            </ul>
                        </div>
                    ))}
                </div>
            )}
        </div>
    );
}

// Basic styling for the application
const styles = {
    container: {
        fontFamily: 'Arial, sans-serif',
        maxWidth: '800px',
        margin: '20px auto',
        padding: '20px',
        border: '1px solid #ddd',
        borderRadius: '8px',
        boxShadow: '0 2px 4px rgba(0,0,0,0.1)',
        backgroundColor: '#f9f9f9',
    },
    header: {
        textAlign: 'center',
        color: '#333',
        marginBottom: '30px',
    },
    form: {
        backgroundColor: '#fff',
        padding: '20px',
        borderRadius: '8px',
        boxShadow: '0 1px 3px rgba(0,0,0,0.05)',
        marginBottom: '30px',
    },
    inputGroup: {
        marginBottom: '15px',
        display: 'flex',
        flexDirection: 'column',
    },
    label: {
        marginBottom: '5px',
        fontWeight: 'bold',
        color: '#555',
    },
    input: {
        padding: '10px',
        border: '1px solid #ccc',
        borderRadius: '4px',
        fontSize: '16px',
        width: 'calc(100% - 22px)', // Adjust for padding and border
        boxSizing: 'border-box',
    },
    extractButton: {
        marginTop: '10px',
        padding: '10px 15px',
        backgroundColor: '#007bff',
        color: 'white',
        border: 'none',
        borderRadius: '4px',
        cursor: 'pointer',
        fontSize: '16px',
        alignSelf: 'flex-start',
    },
    button: {
        padding: '12px 20px',
        backgroundColor: '#28a745',
        color: 'white',
        border: 'none',
        borderRadius: '4px',
        cursor: 'pointer',
        fontSize: '18px',
        width: '100%',
        marginTop: '10px',
    },
    buttonDisabled: {
        backgroundColor: '#cccccc',
        cursor: 'not-allowed',
    },
    error: {
        color: 'red',
        backgroundColor: '#ffe0e0',
        border: '1px solid red',
        padding: '10px',
        borderRadius: '4px',
        marginBottom: '20px',
        textAlign: 'center',
    },
    listHeader: {
        color: '#333',
        marginBottom: '20px',
        borderBottom: '2px solid #eee',
        paddingBottom: '10px',
    },
    paperListContainer: {
        backgroundColor: '#fff',
        padding: '20px',
        borderRadius: '8px',
        boxShadow: '0 1px 3px rgba(0,0,0,0.05)',
    },
    letterGroup: {
        marginBottom: '25px',
    },
    letterHeading: {
        backgroundColor: '#e9ecef',
        padding: '8px 15px',
        borderRadius: '4px',
        marginBottom: '15px',
        color: '#495057',
        fontSize: '1.2em',
    },
    paperList: {
        listStyleType: 'none',
        padding: 0,
        margin: 0,
    },
    paperItem: {
        backgroundColor: '#f8f9fa',
        border: '1px solid #dee2e6',
        borderRadius: '5px',
        padding: '15px',
        marginBottom: '10px',
        display: 'flex',
        flexDirection: 'column',
    },
    paperLink: {
        fontSize: '1.1em',
        color: '#007bff',
        textDecoration: 'none',
        fontWeight: 'bold',
        marginBottom: '5px',
    },
    paperLinkHover: {
        textDecoration: 'underline',
    },
    keywords: {
        fontSize: '0.9em',
        color: '#6c757d',
        fontStyle: 'italic',
        marginTop: '5px',
    },
    loadingContainer: {
        display: 'flex',
        justifyContent: 'center',
        alignItems: 'center',
        height: '100vh',
        fontSize: '20px',
        color: '#555',
    }
};
